{
  "manifest": {
    "name": "streamx",
    "version": "2.15.1",
    "description": "An iteration of the Node.js core streams with a series of improvements",
    "main": "index.js",
    "dependencies": {
      "fast-fifo": "^1.1.0",
      "queue-tick": "^1.0.1"
    },
    "devDependencies": {
      "brittle": "^3.1.1",
      "end-of-stream": "^1.4.4",
      "standard": "^17.0.0"
    },
    "files": [
      "index.js"
    ],
    "scripts": {
      "test": "standard && brittle test/*.js"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/mafintosh/streamx.git"
    },
    "author": {
      "name": "Mathias Buus",
      "url": "@mafintosh"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/mafintosh/streamx/issues"
    },
    "homepage": "https://github.com/mafintosh/streamx",
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-streamx-2.15.1-396ad286d8bc3eeef8f5cea3f029e81237c024c6-integrity/node_modules/streamx/package.json",
    "readmeFilename": "README.md",
    "readme": "# streamx\n\nAn iteration of the Node.js core streams with a series of improvements.\n\n```\nnpm install streamx\n```\n\n[![Build Status](https://github.com/streamxorg/streamx/workflows/Build%20Status/badge.svg)](https://github.com/streamxorg/streamx/actions?query=workflow%3A%22Build+Status%22)\n\n## Main improvements from Node.js core stream\n\n#### Proper lifecycle support.\n\nStreams have an `_open` function that is called before any read/write operation and a `_destroy`\nfunction that is always run as the last part of the stream.\n\nThis makes it easy to maintain state.\n\n#### Easy error handling\n\nFully integrates a `.destroy()` function. When called the stream will wait for any\npending operation to finish and call the stream destroy logic.\n\nClose is *always* the last event emitted and `destroy` is always run.\n\n#### `pipe()` error handles\n\n`pipe` accepts a callback that is called when the pipeline is fully drained.\nIt also error handles the streams provided and destroys both streams if either\nof them fail.\n\n#### All streams are both binary and object mode streams\n\nA `map` function can be provided to map your input data into buffers\nor other formats. To indicate how much buffer space each data item takes\nan `byteLength` function can be provided as well.\n\nThis removes the need for two modes of streams.\n\n#### Simplicity\n\nThis is a full rewrite, all contained in one file.\n\nLots of stream methods are simplified based on how I and devs I work with actually use streams in the wild.\n\n#### Backwards compat\n\nstreamx aims to be compatible with Node.js streams whenever it is reasonable to do so.\n\nThis means that streamx streams behave a lot like Node.js streams from the outside but still provides the\nimprovements above.\n\n#### Smaller browser footprint\n\nstreamx has a much smaller footprint when compiled for the browser:\n\n```\n$ for x in stream{,x}; do echo $x: $(browserify -r $x | wc -c) bytes; done\nstream: 173844 bytes\nstreamx: 46943 bytes\n```\n\nWith optimizations turned on, the difference is even more stark:\n\n```\n$ for x in stream{,x}; do echo $x: $(browserify -r $x -p tinyify | wc -c) bytes; done\nstream: 62649 bytes\nstreamx: 8460 bytes\n$ for x in stream{,x}; do echo $x: $(browserify -r $x -p tinyify | gzip | wc -c) \"bytes (gzipped)\"; done\nstream: 18053 bytes (gzipped)\nstreamx: 2806 bytes (gzipped)\n```\n\n#### AbortSignal support\n\nTo make it easier to integrate streams in a `async/await` flow, all streams support a `signal` option\nthat accepts a [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) to as an\nalternative means to `.destroy` streams.\n\n## Usage\n\n``` js\nconst { Readable } = require('streamx')\n\nconst rs = new Readable({\n  read (cb) {\n    this.push('Cool data')\n    cb(null)\n  }\n})\n\nrs.on('data', data => console.log('data:', data))\n```\n\n## API\n\nThis streamx package contains 4 streams similar to Node.js core.\n\n## Readable Stream\n\n#### `rs = new stream.Readable([options])`\n\nCreate a new readable stream.\n\nOptions include:\n\n```\n{\n  highWaterMark: 16384, // max buffer size in bytes\n  map: (data) => data, // optional function to map input data\n  byteLength: (data) => size, // optional function that calculates the byte size of input data\n  signal: abortController.signal, // optional AbortSignal that triggers `.destroy` when on `abort`\n  eagerOpen: false // eagerly open the stream\n}\n```\n\nIn addition you can pass the `open`, `read`, and `destroy` functions as shorthands in\nthe constructor instead of overwrite the methods below.\n\nThe default byteLength function returns the byte length of buffers and `1024`\nfor any other object. This means the buffer will contain around 16 non buffers\nor buffers worth 16kb when full if the defaults are used.\n\n#### `rs._read(cb)`\n\nThis function is called when the stream wants you to push new data.\nOverwrite this and add your own read logic.\nYou should call the callback when you are fully done with the read.\n\nCan also be set using `options.read` in the constructor.\n\nNote that this function differs from Node.js streams in that it takes\nthe \"read finished\" callback.\n\n#### `drained = rs.push(data)`\n\nPush new data to the stream. Returns true if the buffer is not full\nand you should push more data if you can.\n\nIf you call `rs.push(null)` you signal to the stream that no more\ndata will be pushed and that you want to end the stream.\n\n#### `data = rs.read()`\n\nRead a piece of data from the stream buffer. If the buffer is currently empty\n`null` will be returned and you should wait for `readable` to be emitted before\ntrying again. If the stream has been ended it will also return `null`.\n\nNote that this method differs from Node.js streams in that it does not accept\nan optional amounts of bytes to consume.\n\n#### `rs.unshift(data)`\n\nAdd a piece of data to the front of the buffer. Use this if you read too much\ndata using the `rs.read()` function.\n\n#### `rs._open(cb)`\n\nThis function is called once before the first read is issued. Use this function\nto implement your own open logic.\n\nCan also be set using `options.open` in the constructor.\n\n#### `rs._destroy(cb)`\n\nThis function is called just before the stream is fully destroyed. You should\nuse this to implement whatever teardown logic you need. The final part of the\nstream life cycle is always to call destroy itself so this function will always\nbe called wheather or not the stream ends gracefully or forcefully.\n\nCan also be set using `options.destroy` in the constructor.\n\nNote that the `_destroy` might be called without the open function being called\nin case no read was ever performed on the stream.\n\n#### `rs._predestroy()`\n\nA simple hook that is called as soon as the first `stream.destroy()` call is invoked.\n\nUse this in case you need to cancel pending reads (if possible) instead of waiting for them to finish.\n\nCan also be set using `options.predestroy` in the constructor.\n\n#### `rs.destroy([error])`\n\nForcefully destroy the stream. Will call `_destroy` as soon as all pending reads have finished.\nOnce the stream is fully destroyed `close` will be emitted.\n\nIf you pass an error this error will be emitted just before `close` is, signifying a reason\nas to why this stream was destroyed.\n\n#### `rs.pause()`\n\nPauses the stream. You will only need to call this if you want to pause a resumed stream.\n\nReturns this stream instance.\n\n#### `rs.resume()`\n\nWill start reading data from the stream as fast as possible.\n\nIf you do not call this, you need to use the `read()` method to read data or the `pipe()` method to\npipe the stream somewhere else or the `data` handler.\n\nIf none of these option are used the stream will stay paused.\n\nReturns this stream instance.\n\n#### `bool = Readable.isPaused(rs)`\n\nReturns `true` if the stream is paused, else `false`.\n\n#### `writableStream = rs.pipe(writableStream, [callback])`\n\nEfficently pipe the readable stream to a writable stream (can be Node.js core stream or a stream from this package).\nIf you provide a callback the callback is called when the pipeline has fully finished with an optional error in case\nit failed.\n\nTo cancel the pipeline destroy either of the streams.\n\n#### `rs.on('readable')`\n\nEmitted when data is pushed to the stream if the buffer was previously empty.\n\n#### `rs.on('data', data)`\n\nEmitted when data is being read from the stream. If you attach a data handler you are implicitly resuming the stream.\n\n#### `rs.on('end')`\n\nEmitted when the readable stream has ended and no data is left in it's buffer.\n\n#### `rs.on('close')`\n\nEmitted when the readable stream has fully closed (i.e. it's destroy function has completed)\n\n#### `rs.on('error', err)`\n\nEmitted if any of the stream operations fail with an error. `close` is always emitted right after this.\n\n#### `rs.on('piping', dest)`\n\nEmitted when the readable stream is pipeing to a destination.\n\n#### `rs.destroyed`\n\nBoolean property indicating wheather or not this stream has been destroyed.\n\n#### `bool = Readable.isBackpressured(rs)`\n\nStatic method to check if a readable stream is currently under backpressure.\n\n#### `stream = Readable.from(arrayOrBufferOrStringOrAsyncIterator)`\n\nStatic method to turn an array or buffer or string or AsyncIterator into a readable stream.\n\n## Writable Stream\n\n#### `ws = new stream.Writable([options])`\n\nCreate a new writable stream.\n\nOptions include:\n\n```\n{\n  highWaterMark: 16384, // max buffer size in bytes\n  map: (data) => data, // optional function to map input data\n  byteLength: (data) => size, // optional function that calculates the byte size of input data\n  signal: abortController.signal // optional AbortSignal that triggers `.destroy` when on `abort`\n}\n```\n\nIn addition you can pass the `open`, `write`, `final`, and `destroy` functions as shorthands in\nthe constructor instead of overwrite the methods below.\n\nThe default byteLength function returns the byte length of buffers and `1024`\nfor any other object. This means the buffer will contain around 16 non buffers\nor buffers worth 16kb when full if the defaults are used.\n\n#### `ws._open(cb)`\n\nThis function is called once before the first write is issued. Use this function\nto implement your own open logic.\n\nCan also be set using `options.open` in the constructor.\n\n#### `ws._destroy(cb)`\n\nThis function is called just before the stream is fully destroyed. You should\nuse this to implement whatever teardown logic you need. The final part of the\nstream life cycle is always to call destroy itself so this function will always\nbe called wheather or not the stream ends gracefully or forcefully.\n\nCan also be set using `options.destroy` in the constructor.\n\nNote that the `_destroy` might be called without the open function being called\nin case no write was ever performed on the stream.\n\n#### `ws._predestroy()`\n\nA simple hook that is called as soon as the first `stream.destroy()` call is invoked.\n\nUse this in case you need to cancel pending writes (if possible) instead of waiting for them to finish.\n\nCan also be set using `options.predestroy` in the constructor.\n\n#### `ws.destroy([error])`\n\nForcefully destroy the stream. Will call `_destroy` as soon as all pending reads have finished.\nOnce the stream is fully destroyed `close` will be emitted.\n\nIf you pass an error this error will be emitted just before `close` is, signifying a reason\nas to why this stream was destroyed.\n\n#### `drained = ws.write(data)`\n\nWrite a piece of data to the stream. Returns `true` if the stream buffer is not full and you\nshould keep writing to it if you can. If `false` is returned the stream will emit `drain`\nonce it's buffer is fully drained.\n\n#### `ws._write(data, callback)`\n\nThis function is called when the stream want to write some data. Use this to implement your own\nwrite logic. When done call the callback and the stream will call it again if more data exists in the buffer.\n\nCan also be set using `options.write` in the constructor.\n\n#### `ws._writev(batch, callback)`\n\nSimilar to `_write` but passes an array of all data in the current write buffer instead of the oldest one.\nUseful if the destination you are writing the data to supports batching.\n\nCan also be set using `options.writev` in the constructor.\n\n#### `ws.end()`\n\nGracefully end the writable stream. Call this when you no longer want to write to the stream.\n\nOnce all writes have been fully drained `finish` will be emitted.\n\nReturns this stream instance.\n\n#### `ws._final(callback)`\n\nThis function is called just before `finish` is emitted, i.e. when all writes have flushed but `ws.end()`\nhave been called. Use this to implement any logic that should happen after all writes but before finish.\n\nCan also be set using `options.final` in the constructor.\n\n#### `ws.on('finish')`\n\nEmitted when the stream has been ended and all writes have been drained.\n\n#### `ws.on('close')`\n\nEmitted when the readable stream has fully closed (i.e. it's destroy function has completed)\n\n#### `ws.on('error', err)`\n\nEmitted if any of the stream operations fail with an error. `close` is always emitted right after this.\n\n#### `ws.on('pipe', src)`\n\nEmitted when a readable stream is being piped to the writable one.\n\n#### `ws.destroyed`\n\nBoolean property indicating wheather or not this stream has been destroyed.\n\n#### `bool = Writable.isBackpressured(ws)`\n\nStatic method to check if a writable stream is currently under backpressure.\n\n#### `bool = await Writable.drained(ws)`\n\nStatic helper to wait for a stream to drain the currently queued writes.\nReturns true if they were drained and false otherwise if the stream was destroyed.\n\n## Duplex Stream\n\n#### `s = new stream.Duplex([options])`\n\nA duplex stream is a stream that is both readable and writable.\n\nSince JS does not support multiple inheritance it inherits directly from Readable\nbut implements the Writable API as well.\n\nIf you want to provide only a map function for the readable side use `mapReadable` instead.\nIf you want to provide only a byteLength function for the readable side use `byteLengthReadable` instead.\n\nSame goes for the writable side but using `mapWritable` and `byteLengthWritable` instead.\n\n## Transform Stream\n\nA Transform stream is a duplex stream with an `._transform` template method that allows to\nasynchronously map the input to a different output.\n\nThe transform stream overrides the `_write` and `_read` operations of `Readable` and `Writable` but\nstill allows the setting of these options in the constructor. Usually it is unnecessary to pass\nin `read` or `write`/`writev` or to override the corresponding `._read`, `._write` or `._writev` operation.\n\n#### `ts = new stream.Transform([options])`\n\nA transform stream is a duplex stream that maps the data written to it and emits that as readable data.\n\nHas the same options as a duplex stream except you can provide a `transform` function also.\n\n#### `ts._transform(data, callback)`\n\nTransform the incoming data. Call `callback(null, mappedData)` or use `ts.push(mappedData)` to\nreturn data to the readable side of the stream.\n\nPer default the transform function just remits the incoming data making it act as a pass-through stream.\n\n## Pipeline\n\n`pipeline` allows to stream form a readable through a set of duplex streams to a writable entry.\n\n```js\nconst { pipeline, Readable, Transform, Writable } = require('streamx')\nconst lastStream = pipeline(\n  Readable.from([1, 2, 3]),\n  new Transform({\n    transform (from, cb) {\n      this.push(from.toString())\n      cb()\n    }\n  }),\n  new Writable({\n    write (data, cb) {\n      console.log(data)\n      cb()\n    }\n  })\n  error => {\n    // Callback once write has finished\n  }\n)\n```\n\n#### `lastStream = stream.pipeline(...streams, [done])`\n\nPipe all streams together and return the last stream piped to.\nWhen the last stream finishes the pipeline ended succesfully.\n\nIf any of the streams error, whether they are Node.js core streams\nor streamx streams, all streams in the pipeline are shutdown.\n\nOptionally you can pass a done callback to know when the pipeline is done.\n\n#### `promise = stream.pipelinePromise(...streams)`\n\nSame as normal pipeline except instead of returning the last stream it returns\na promise representing the done callback. Note you should error handle this\npromise if you use this version.\n\n## Utilities\n\nStreamx aims to be minimal and stable. It therefore only contains a minimal set of utilities.\nTo help discover of other modules that help you build streamx apps, we link some useful utilities here\n\n* [stream-composer](https://github.com/mafintosh/stream-composer) - Compose streams like Node's `stream.compose` and the `duplexify` and `pumpify` modules.\n* [teex](https://github.com/mafintosh/teex) - Clone a readable stream into multiple new readable instances.\n\n## Contributing\n\nIf you want to help contribute to streamx a good way to start is to help writing more test\ncases, compatibility tests, documentation, or performance benchmarks.\n\nIf in doubt open an issue :)\n\n## License\n\nMIT\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2019 Mathias Buus\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/streamx/-/streamx-2.15.1.tgz#396ad286d8bc3eeef8f5cea3f029e81237c024c6",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/streamx/-/streamx-2.15.1.tgz",
    "hash": "396ad286d8bc3eeef8f5cea3f029e81237c024c6",
    "integrity": "sha512-fQMzy2O/Q47rgwErk/eGeLu/roaFWV0jVsogDmrszM9uIw8L5OA+t+V93MgYlufNptfjmYR1tOMWhei/Eh7TQA==",
    "registry": "npm",
    "packageName": "streamx",
    "cacheIntegrity": "sha512-fQMzy2O/Q47rgwErk/eGeLu/roaFWV0jVsogDmrszM9uIw8L5OA+t+V93MgYlufNptfjmYR1tOMWhei/Eh7TQA== sha1-OWrShti8Pu749c6j8CnoEjfAJMY="
  },
  "registry": "npm",
  "hash": "396ad286d8bc3eeef8f5cea3f029e81237c024c6"
}